{"version":3,"sources":["useAnimationFrame.js","Smoke.js","serviceWorker.js","index.js"],"names":["useAnimationFrame","callback","requestRef","React","useRef","previousTimeRef","useEffect","current","requestAnimationFrame","animate","time","undefined","deltaTime","cancelAnimationFrame","Smoke","useDimensions","ref","width","height","useState","count","setCount","canvasRef","particles","setParticles","x","dx","ddx","wind","setWind","windtarget","setWindTarget","position","y","setPosition","setFromEvent","e","clientX","clientY","window","addEventListener","removeEventListener","useMousePosition","prevCount","randbetween","miny","maxy","Math","random","Number","isFinite","vx","vy","ctx","getContext","countarray","Array","from","length","_","index","positionx","positiony","map","push","filter","particle","direction","console","log","windchange","aparticle","sidepush","modifier","clearRect","beginPath","fillStyle","fillRect","stroke","className","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.a4b2dad3.chunk.js","sourcesContent":["import React from \"react\";\r\n\r\nconst useAnimationFrame = callback => {\r\n    // Use useRef for mutable variables that we want to persist\r\n    // without triggering a re-render on their change\r\n    const requestRef = React.useRef();\r\n    const previousTimeRef = React.useRef();\r\n\r\n\r\n\r\n    React.useEffect(() => {\r\n        const animate = time => {\r\n            if (previousTimeRef.current !== undefined) {\r\n                const deltaTime = time - previousTimeRef.current;\r\n                callback(deltaTime)\r\n            }\r\n            previousTimeRef.current = time;\r\n            requestRef.current = requestAnimationFrame(animate);\r\n        }\r\n\r\n        requestRef.current = requestAnimationFrame(animate);\r\n        return () => cancelAnimationFrame(requestRef.current);\r\n    }, []); // Make sure the effect runs only once\r\n}\r\n\r\nexport default useAnimationFrame\r\n","import React, {useState, useEffect}  from \"react\";\r\nimport useDimensions from \"react-cool-dimensions\";\r\nimport useAnimationFrame from './useAnimationFrame'\r\nimport './Smoke.css';\r\n\r\nexport const useMousePosition = () => {\r\n    const [position, setPosition] = useState({ x: 0, y: 0 });\r\n\r\n    useEffect(() => {\r\n        const setFromEvent = e => setPosition({ x: e.clientX, y: e.clientY });\r\n        window.addEventListener(\"mousemove\", setFromEvent);\r\n\r\n        return () => {\r\n            window.removeEventListener(\"mousemove\", setFromEvent);\r\n        };\r\n    }, []);\r\n\r\n    return position;\r\n};\r\n\r\nconst Smoke = () => {\r\n    const { ref, width, height} = useDimensions();\r\n    const [count, setCount] = useState(0)\r\n    const [delta, setDelta] = useState(0)\r\n    const canvasRef = React.useRef();\r\n    const [particles, setParticles] = useState(undefined)\r\n    const [wind, setWind] = useState({x: 1, dx: 0.1, ddx: 0 })\r\n    const [windtarget, setWindTarget] = useState(1)\r\n    const position = useMousePosition()\r\n\r\n    useAnimationFrame(deltaTime => {\r\n        // Pass on a function to the setter of the state\r\n        // to make sure we always have the latest state\r\n        setCount(prevCount => (prevCount + deltaTime * 0.01))\r\n    })\r\n\r\n    useEffect(() => {\r\n        const randbetween = (miny, maxy) => {\r\n            return ((maxy - miny) * Math.random() + miny)\r\n        }\r\n        if (particles === undefined) {\r\n            if ( Number.isFinite(width) && width > 0) {\r\n                setParticles([{x: width / 2, y: height - 20, vx: 0, vy: -0.5}])\r\n            }\r\n        }\r\n        else {\r\n            const canvas = canvasRef.current\r\n            const ctx = canvas.getContext('2d')\r\n\r\n            const countarray = Array.from({length: 25}, (_, index) => index + 1);\r\n            let positionx = width /2\r\n            let positiony = height - 20\r\n            if (position.x) {\r\n                positionx = position.x\r\n                positiony = position.y\r\n            }\r\n            countarray.map(() => {particles.push({x: positionx, y: positiony, vx: 0, vy: randbetween(3, 7) * -1})})\r\n            particles.filter(particle => particle.height > 0 && particle.vy < -0.1)\r\n            if (randbetween(0, 1) < 0.07) {\r\n                let direction = 1\r\n                if (wind.x > 0) {\r\n                    direction = -1\r\n                }\r\n                setWindTarget(direction * randbetween(0, 4))\r\n                console.log(\"wind changed\")\r\n            }\r\n            let windchange = 0\r\n            if (wind.x > windtarget) {\r\n                windchange = wind.dx * -1\r\n            } else {\r\n                windchange = wind.dx\r\n            }\r\n            setWind({x: wind.x + windchange, dx: wind.dx, ddx: 0 })\r\n            setParticles(particles.map((aparticle) => {\r\n                let sidepush = (((aparticle.x - (width / 2)) * -1) / (width / 2)) * 6\r\n                let modifier = ((aparticle.y / height) ** 2)\r\n                sidepush *= modifier\r\n                return {x: aparticle.x + aparticle.vx + sidepush + wind.x, y: aparticle.y + aparticle.vy, vx: randbetween(-5, 5) * (1 - modifier), vy: aparticle.vy}\r\n            }))\r\n            ctx.clearRect(0, 0, width, height)\r\n            particles.map((aparticle) => {\r\n                ctx.beginPath()\r\n                ctx.fillStyle = \"#FFFFFF\";\r\n                ctx.fillRect(aparticle.x, aparticle.y, 1, 1);\r\n                ctx.stroke()\r\n            })\r\n        }\r\n    }, [count])\r\n\r\n\r\n    return <div ref={ref} className={'Smoke'}>\r\n            <canvas ref={canvasRef} width={width} height={height - 10}/>\r\n    </div>\r\n};\r\n\r\nexport default Smoke;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n// import FishTank from './FishTank';\nimport Smoke from './Smoke'\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Smoke />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}